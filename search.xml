<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解计算机系统CH-01]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCH01%2F</url>
    <content type="text"><![CDATA[深入理解计算机系统CH-1 源程序源程序实际上由0和1组成的位（又称比特序列）序列，这些位被组织成8个一组，称为字节。每个字节都表示程序中某个文本字符。大部分现代系统都使用ASCII标准来表示文本字符。 基本思想：系统中所有的信息————包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 编译系统执行四个阶段的程序（预处理器，编译器，汇编器和连接器）一起构成了编译系统 预处理阶段：预处理器(cpp)根据以字符#开头的命令修改原始c程序。如#include 即告知预处理器读取系统头文件stdio.h内容，将其插入程序文本，得到一个.i程序 编译阶段：编译器(ccl)将文本文件.i翻译成汇编程序文本文件.s，包含一个汇编语言程序 汇编阶段：汇编器(as)将.s文件翻译成机器语言指令，把这些指令打包成为一种叫做可重定位(relocatable)目标程序的格式，并将结果保存在目标文件.o(二进制文件)中。 链接阶段：链接器(ld)负责处理库中的函数以某种方式并入.o程序中，结果得到一个可执行目标文件。可执行文件加载到存储器，由系统负责执行。 编译系统益处 优化程序性能 理解链接时出现的错误 避免安全漏洞 系统硬件组成 总线：贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)。 I/O设备：系统与外界的联系通道，例如USB控制器，图形适配器，硬盘控制器等。每个I/O设备都是通过一个控制器或适配器与I/O总现连接起来的。 主存：主存是一个临时存储设备，在处理器执行程序时，它被用来存放程序和程序处理的数据。物理上来说，是由一组DRAM(动态随机存储器)芯片组成。逻辑上来说，存储器是由一个线性的字节数组组成的，每个字节都有唯一的地址(数组索引)，这些地址是从零开始的。 处理器：中央处理单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器(PC)的字节大小的存储设备(或寄存器)。在任何一个时间点上，PC都指向主存中的某条机器语言指令(内含其地址)。 执行hello程序过程 在键盘中输入./hello后，shell程序逐一读取字符至寄存器。 按回车后，结束命令输入，将hello目标文件中的代码与数据拷至主存，加载hello文件。数据包括输出字符串。 加载完毕后，处理器执行主程序中的机器语言指令。这些指令将字符串中的字节从存储器中拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备。 高速缓存针对处理器与主存存放字节数，读写速度以及运行速度的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器(cache memories，简称高速缓存) 存储设备的层次结构实际上，每个计算机系统中的存储设备都被组织成一个存储器层次模型。其主要思想是一个层次上的存储器作为下一层次上的存储器的高速缓存。利用对整个存储器层次模型的理解，可以提高程序的性能 操作系统管理硬件操作系统有两个基本功能： 防止硬件被失控的应用程序滥用 在控制复杂而又广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。 操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)实现这两个功能。 其中文件是对I/O设备的抽象表示，虚拟存储器是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 进程操作系统运行程序的一种抽象。一个系统上可以同时运行多个进程，称之为并发运行。 实际上进程指令是交错执行的。操作系统实现交错执行的机制称为上下文切换(context switching)。 操作系统保存进程运行所需的所有状态信息，这种状态称之为上下文(context)。当操作系统决定从当前进程转移控制权到某个新进程时候，就会发生上下文切换。 线程一个进程可以由多个称为线程的执行单位组成，每个线程都运行进程的上下文中，并共享同样的模型和全局数据。 虚拟存储器虚拟存储器是一个抽象概念。每个进程看到的存储器是一致的，称为虚拟地址空间 每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。 程序代码和数据：由可执行文件目标直接初始化。 堆：堆可以在运行时候动态的扩展和收缩 共享库：存放共享库和数据的区域 栈：位于用户虚拟空间地址顶部，编译器用它来实现函数调用 内核虚拟存储器：内核是操作系统总是驻留在存储器中的部分 文件文件即是字节序列。]]></content>
      <tags>
        <tag>Computer System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 + Selenium + ChromeDriver 初探]]></title>
    <url>%2F2019%2F01%2F15%2Fselenium%2F</url>
    <content type="text"><![CDATA[简介Selenium是一个用于Web应用程序测试的工具。它直接运行在浏览器中，就像真正的用户在操作一样。运用这种特性，可以用于简单爬虫。 配置环境ChromeDriver下载相应版本的ChromeDriver，版本对应请看文件夹里面的note.txt文件。 Selenium1sudo pip3 install Selenium 模拟登录实现12345678910111213141516171819202122232425262728293031323334353637383940from selenium import webdriverimport osimport csvimport timeID = ""PASSWORD = ""chromedriver = "../Chrome_Driver/2.40/chromedriver"os.environ["webdriver.chrome.driver"] = chromedriverdriver = webdriver.Chrome(chromedriver)driver.get("http://jwxt.zufe.edu.cn/jwglxt/xtgl/login_slogin.html?language=zh_CN&amp;_t=1547536545893")inputID = driver.find_element_by_id("yhm")inputPASSWORD = driver.find_element_by_id("mm")clickButton = driver.find_element_by_id("dl")inputID.clear()inputPASSWORD.clear()inputID.send_keys(ID)inputPASSWORD.send_keys(PASSWORD)clickButton.click()driver.get("http://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxDgXscj.html?gnmkdm=N305005&amp;layout=default&amp;su=%s" %ID)time.sleep(10)driver.find_element_by_id("search_go").click()table_rows = driver.find_element_by_tag_name("tbody").find_elements_by_tag_name("tr")rowsLen = len(table_rows)CSVPATH = "../Data/Score.csv"with open(CSVPATH,'w') as f: csv_write = csv.writer(f) csv_head = ["学年","学期","课程编号","课程名","课程类型","学分","成绩"] csv_write.writerow(csv_head) for i in range(1,rowsLen): csv_write.writerow(table_rows[i].text.split(" ")[1:8]) Socks Proxy12345678910111213141516from selenium import webdriverPORT = 1088chrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--proxy-server=socks5://localhost:%s' %PORT)browser = webdriver.Chrome(chrome_options=chrome_options, executable_path='../Chrome_Driver/2.40/chromedriver')proxy.new_har('youtube')browser.get('http://www.google.com')browser.find_element_by_name("q")inputContent = browser.find_element_by_name("q")inputContent.clear()inputContent.send_keys("asmire.site")submit = browser.find_elements_by_name("btnK")submit[-1].click() 即可访问外网。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习资料整合(不断更新)]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[符号标识： 完成 在做 未完成 √ - × 教材 机器学习原本在读的是&lt;&lt;机器学习实战&gt;&gt;，每一章都做一个归纳和总结。结果在github上找到了各章节负责人的总结。作为参考,如果有补充的,就做归纳和总结。 统计机器学习 - 西瓜书 - 机器学习实战 - 花书 × 深度学习入门 × tensorflow实战 × Andrew ng 视频 × 机器学习入门 - Kaggle × 数学概率 概率导论 - 应用随机过程 × 代数 代数学引论 代数学引论(一) × 代数学引论(二) × 代数学引论(三) × 北大高代 × 高数 数学分析八讲 × 吉米多维奇习题集 吉米多维奇习题集(一) × 吉米多维奇习题集(二) × 吉米多维奇习题集(三) × 吉米多维奇习题集(四) × 吉米多维奇习题集(五) × 吉米多维奇习题集(六) × 网络安全 34个信息安全项目]]></content>
      <tags>
        <tag>Learning Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Josephus Problem]]></title>
    <url>%2F2018%2F09%2F09%2FThe-Josephus-Problem%2F</url>
    <content type="text"><![CDATA[简介约瑟夫问题： 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。现在我们将问题一般化，即问题为： n个人围成一圈，从围成标记号为1到n的圆圈的n个人开始，每隔一个删去一个人，直到只有一个人幸存下来。求确定幸存者的号码 $J(n)$ 解法递归不妨从奇偶性开始考虑当$n$为偶数时，我们考虑 $J(2n)$ 的情况。第一轮后，还剩下n个人。此时发现编号符合映射: $x \rightarrow y = 2x-1$,可得到 $J(2n) = 2J(n)-1$同理，当 $n$ 为奇数时,我们考虑 $J(2n+1)$ 的情况，此时可得：$J(2n+1)=2J(n)+1$ 故定义$J$的递归式为： J(1) = 1J(2n) = 2J(n)-1, n\geq1J(2n+1) = 2J(n) + 1,n\geq1封闭形式通过递归式，我们可以观察解从而将递归式转化为封闭形式的解。 $n$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $J(n)$ 1 1 3 1 3 5 7 1 3 5 7 9 11 13 15 1 通过观察，如果我们将 $n$ 写成 $n=2^m+l$ ,则递归式解为： J(2^m+l) = 2l+1, m\geq0, 0\leq l < 2^m.约束条件为： 2^m\leq n\leq 2^{m+1}证明可用数学归纳法证明，此处略。 进制通过求解封闭形式，我们发现2的幂起着重要作用。于是研究以2为基数的表示方法。假设n的二进制展开式为 ${(b{_m}b_{m-1}b_{m-2}\cdots b_1b_0)}_2$ ，$b$ 取0或1，$b_m$=1.我们依次可得： n={(1b_{m-1}b_{m-2}\cdots b_1b_0)}_2l={(0b_{m-1}b_{m-2}\cdots b_1b_0)}_22l={(b_{m-1}b_{m-2}\cdots b_1b_00)}_22l+1={(b_{m-1}b_{m-2}\cdots b_1b_01)}_2J(n)={(b_{m-1}b_{m-2}\cdots b_1b_0b_m)}_2二进制下即可数位循环移动得到最终解。 扩展不动点若对 $J(n)$ 不断迭代，则最后会达到一个不动点，在该点有 $J(n)=n$.设 $J(n)$ 二进制中有k个1,则不断迭代后，$n=2^{k}-1$. 递归式通解f(1) = \alphaf(2n) = 2f(n) + \beta ,n \geq 1f(2n+1) = 2f(n) + \gamma ,n \geq 1对n的前几项列出表格 $n$ 1 2 3 4 5 6 $J(n)$ $\alpha$ $2\alpha+\beta+0\gamma$ $2\alpha+0\beta+1\gamma$ $4\alpha+3\beta+0\gamma$ $4\alpha+2\beta+1\gamma$ $4\alpha+1\beta+2\gamma$ 将 $f(n)$ 与 $\alpha,\beta,\gamma$ 的依存关系分离开来，表示为： f(n)=A(n)\alpha+B(n)\beta+C(n)\gamma可通过归纳法证得： A(n) = 2^mB(n) = 2^m-1-lC(n) = l其中有 $n=2^m+l$ 以及 $0\leq l&lt;2^m$ $(n\geq 1)$ 成套解法(repertoire method)从 $f(n)$ 出发，并研究是否有任意常数 $(\alpha,\beta,\gamma)$ 能定义它。 当 $f(n)=1$，可得解 $(\alpha,\beta,\gamma)=(1,-1,-1)$ , $A(n)-B(n)-C(n)=f(n)=1$同理当$ f(n)=n$ 时， $(\alpha,\beta,\gamma)=(1,0,1)$ 时对所有的n成立，故$ A(n)+C(n)=f(n)=n$ 可得： A(n) = 2^mA(n)-B(n)-C(n)=1A(n)+C(n)=n解同上. 进制通解令 $\beta_0 = \beta$ 以及 $\beta_1 = \gamma$，则推广递归式改写成 f(1) = \alphaf(2n+j) = 2f(n) + \beta_ j, j = 0,1,n\geq 1递归式由上两式按二进制展开为： f(n) = f((b_mb_{m-1}\cdots b_1b_0)_2) = 2^m\alpha +2^{m-1}\beta_{b_{m-1}}+\cdots+2\beta_{b_1}+\beta_{b_0}2^m\alpha +2^{m-1}\beta_{b_{m-1}}+\cdots+2\beta_{b_1}+\beta_{b_0} =(\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\cdots \beta_{b_1}\beta_{b_0})_2即 f(n)=(\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\cdots \beta_{b_1}\beta_{b_0})_2求解结束。以下给出例子$\alpha =1,\beta=-1,\gamma=1$,此时 $n=(1100100)_2 = 100$$f(n) = (1$ $ 1-1-1$ $1-1-1)_2 = +64 +32-16-8+4-2-1=73$]]></content>
      <categories>
        <category>Mathematics</category>
        <category>Concrete Mathematics</category>
      </categories>
      <tags>
        <tag>Concrete Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-NearestNeighbor]]></title>
    <url>%2F2018%2F08%2F20%2Fk-NearestNeighbor%2F</url>
    <content type="text"><![CDATA[简介KNN算法是测量不同特征值之间的距离方法进行分类和回归的非参数统计方法，属于懒惰学习(lazy learning)中的一种。 在k-NN分类中，输出是一个分类族群。一个对象的分类是由其邻居的“多数表决”确定的，k个最近邻居（k为正整数，通常较小）中最常见的分类决定了赋予该对象的类别。若 k = 1，则该对象的类别直接由最近的一个节点赋予。 在k-NN回归中，输出是该对象的属性值。该值是其k个最近邻居的值的平均值。 优点 精度高 对异常值不敏感 无数据输入假定 缺点 计算复杂度高、空间复杂度高。时间复杂度为 $O(n)$ 适用范围 该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。 数值型和标称型数据 注： 标称型：一般在有限的数据中取，而且只存在‘是’和‘否’两种不同的结果（一般用于分类）数值型：可以在无限的数据中取，而且数值比较具体化，例如4.02,6.23这种值（一般用于回归分析） 分类算法流程计算已知数据集中的点与当前点的距离12def classifyKNN(inX, dataSet, labels, k): diffMat = (np.tile(inx,(dataSet.shape[0],1)) - dataSet) ** 2 按照距离递增次序排序注: 这里使用欧式距离 12distance = (diffMat.sum(axis = 1)) ** 0.5sortedDistIndicies = distances.argsort() 注： x.argsort: 将x中的元素从小到大排列，提取其对应的index(索引)，然后输出到y。如 x = np.array([1,4,3,-1]), 则输出 array([3, 0, 2, 1]) 选取与当前点距离最小的k个点并统计类别频率12345classCount = &#123;&#125;for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #if label not in classCount,set 0,else it's count plus 1 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 返回前k个点频率最高的类别作为当前点的预测分类12sortedClassCount = sorted(classCount.iteritems(),key = operator.itemgetter(1), reverse = True)return sortedClassCount[0][0] 注: 迭代大数据字典时，如果是使用 items() 方法，那么在迭代之前，迭代器迭代前需要把数据完整地加载到内存，则会造成内存占用大。而 iteritem() 返回一个迭代器(iterators)，迭代器在迭代的时候，迭代元素逐个生成，减少了内存消耗。 分类完整代码123456789101112131415import numpy as npimport pandas as pdimport operator def KNNclassify(inx,dataSet,labels,k): diffMat = np.tile(inx, (dataSet.shape[0], 1)) - dataSet distances = ((diffMat**2).sum(axis = 1))**0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #if voteIlabel not in classCount,set 0,else count plus 1 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse = True) return sortedClassCount[0][0]]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Stat ML</category>
      </categories>
      <tags>
        <tag>Stat ML</tag>
      </tags>
  </entry>
</search>
